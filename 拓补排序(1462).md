### 题目来源
[LeetCode](https://leetcode.cn/problems/course-schedule-iv/description/?envType=daily-question&envId=2023-09-12)

本题考到了**拓扑排序**和**Floyd**的运用

### 拓扑排序
- 首先我们需要知道每一个节点的入度，只有入度为0的节点才能够将其从图中删除，并同时更新其后继节点的入度(-1)；执行完该操作后，再次将入度为0的节点放入队列中，直至队列为空

假设此时题目给定$n$个顶点以及一组相连的边$[i, j]$，表示$i$到$j$有一条有向边
**思路：**
- 首先创建一个``indegree``，用来存储每一个节点的入度值，再创建一个数组`successor`用来存储每一个节点的后继节点(此处仅考虑直接后继)
- 循环遍历edges，更新````indegree````和````successor````
- 将全部入度为0的节点放入队列
- 除非队列为空，否则提取队头元素`cur`将其pop，然后遍历其所有的后继节点`successor[cur]`，并将其入度减1，然后判断如果此时某个节点的入度为0，则将其加入队列

**代码：**
``````[]
//C++ code
vector<int> Topological_sort(int n, vector<vector<int>>& edges)
{
    vector<int> ans;

    // 初始化indegree为n个0，表示初始有n个节点，其入度为0
    vector<int> indegree(n);

    // 初始化后继节点，注：此处为[]代表vector<int>数组
    vector<int> successor[n];
    for(auto& edge : edges)
    {
        successor[edge[0]].push_back(edge[1]);
        ++indegree[edge[1]];
    }
    queue<int> q;
    for(int i = 0; i < n; ++i)
    {
        if(indegree[i] == 0)
        {
            q.push(i);
        }
    }
    while(!q.empty())
    {
        int cur = q.front();
        q.pop();
        ans.push_back();
        for(auto node : successor[cur])
        {
            --indegree[node];
            if(indegree[node] == 0)
            {
                q.push(node);
            }
        }
    }
    return ans;
}
``````