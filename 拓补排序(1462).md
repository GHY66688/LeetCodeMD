### 题目来源
[LeetCode](https://leetcode.cn/problems/course-schedule-iv/description/?envType=daily-question&envId=2023-09-12)

本题考到了**拓扑排序**和**Floyd**的运用

### 拓扑排序
假设给定$n$个顶点以及一组相连的边$[i, j]$，表示$i$到$j$有一条有向边

**思路：**
- 首先创建一个``indegree``，用来存储每一个节点的入度值，再创建一个数组`successor`用来存储每一个节点的后继节点(此处仅考虑直接后继)
- 循环遍历edges，更新````indegree````和````successor````
- 将全部入度为0的节点放入队列
- 除非队列为空，否则提取队头元素`cur`将其pop，然后遍历其所有的后继节点`successor[cur]`，并将其入度减1，然后判断如果此时某个节点的入度为0，则将其加入队列

**代码：**
``````[]
//C++ code
vector<int> Topological_sort(int n, vector<vector<int>>& edges)
{
    vector<int> ans;

    // 初始化indegree为n个0，表示初始有n个节点，其入度为0
    vector<int> indegree(n);

    // 初始化后继节点，注：此处为[]代表vector<int>数组
    vector<int> successor[n];
    for(auto& edge : edges)
    {
        successor[edge[0]].push_back(edge[1]);
        ++indegree[edge[1]];
    }
    queue<int> q;
    for(int i = 0; i < n; ++i)
    {
        if(indegree[i] == 0)
        {
            q.push(i);
        }
    }
    while(!q.empty())
    {
        int cur = q.front();
        q.pop();
        ans.push_back();
        for(auto node : successor[cur])
        {
            --indegree[node];
            if(indegree[node] == 0)
            {
                q.push(node);
            }
        }
    }
    return ans;
}
``````


### Floyd
假设有$n$个节点，并且给定一组向量$[i, j, weight]$表示从点$i$到点$j$有一条有向边且路长为$weight$，求解每一对节点之间的最短路径

**思路：**
- 初始化权重矩阵$Matrix$为INT_MAX
- 自身到自身的权重为0
- 遍历$edges$，存储对应的权重
- 枚举中间节点mid， 枚举头节点head， 枚举尾结点tail
- 如果[head, mid] + [mid, tail] < [head, tail]，更新矩阵

````[]
C++ code
vector<vector<int>> Floyd(int n, vector<vector<int>>& edges)
{
    vector<vector<int>> matrix(n,vector<int>(n, INT_MAX));
    for(int i = 0; i < n; ++i)
    {
        matrix[i][i] = 0;
    }
    for(auto& edge : edges)
    {
        matrix[edge[0]][edge[1]] = edge[2];
    }
    for(int mid = 0; mid < n; ++mid)
    {
        for(int head = 0; head < n; ++head)
        {
            for(int tail = 0; tail < n; ++tail)
            {
                int temp = matrix[head][mid] + matrix[mid][tail];
                if(matrix[head][tail] > temp)
                {
                    matrix[head][tail] = temp;
                }
            }
        }
    }
    return matrix;
}
``````